!-----------------------------------------------------------------------------
! (c) Crown copyright 2024 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Test the subgrid horizontal functions used for FFSL transport

module subgrid_horizontal_support_mod_test

  use constants_mod,                  only: i_def, l_def, r_tran

  implicit none

contains

  !------------------------------------------------------------------

  @test
  subroutine fourth_order_horizontal_edge_test()
    use funit
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: fourth_order_horizontal_edge

    implicit none

    integer(kind=i_def), parameter :: nlayers = 1

    real(kind=r_tran) :: tol
    real(kind=r_tran) :: rho(1:5,nlayers), edge_left(nlayers), edge_right(nlayers)
    real(kind=r_tran) :: answer_left(nlayers), answer_right(nlayers)

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test a linear function
    rho(1,1) = 1.0_r_tran
    rho(2,1) = 3.0_r_tran
    rho(3,1) = 5.0_r_tran
    rho(4,1) = 7.0_r_tran
    rho(5,1) = 9.0_r_tran

    answer_left(1)  = 4.0_r_tran
    answer_right(1) = 6.0_r_tran

    call fourth_order_horizontal_edge(rho, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test a non-linear function
    rho(1,1) = 0.0_r_tran
    rho(2,1) = 10.0_r_tran
    rho(3,1) = 9.0_r_tran
    rho(4,1) = 4.0_r_tran
    rho(5,1) = 6.0_r_tran

    answer_left(1)  = 10.75_r_tran
    answer_right(1) = 6.25_r_tran

    call fourth_order_horizontal_edge(rho, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine fourth_order_horizontal_edge_test

  !------------------------------------------------------------------

  @test
  subroutine nirvana_horizontal_edge_test()
    use funit
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: nirvana_horizontal_edge

    implicit none

    integer(kind=i_def), parameter :: nlayers = 1

    real(kind=r_tran) :: tol
    real(kind=r_tran) :: rho(1:3,nlayers), edge_left(nlayers), edge_right(nlayers)
    real(kind=r_tran) :: answer_left(nlayers), answer_right(nlayers)

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test a linear function
    rho(1,1) = 1.0_r_tran
    rho(2,1) = 3.0_r_tran
    rho(3,1) = 5.0_r_tran

    answer_left(1)  = 2.0_r_tran
    answer_right(1) = 4.0_r_tran

    call nirvana_horizontal_edge(rho, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test a non-linear function
    rho(1,1) = 1.0_r_tran
    rho(2,1) = 4.0_r_tran
    rho(3,1) = 10.0_r_tran

    answer_left(1)  = 2.0_r_tran
    answer_right(1) = 6.5_r_tran

    call nirvana_horizontal_edge(rho, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine nirvana_horizontal_edge_test

!------------------------------------------------------------------

  @test
  subroutine nirvana_special_edge_test()
    use funit
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: nirvana_special_edge

    implicit none

    integer(kind=i_def), parameter :: nlayers = 1

    real(kind=r_tran)   :: rho(nlayers,5)
    real(kind=r_tran)   :: edge_left(nlayers), edge_right(nlayers), tol
    real(kind=r_tran)   :: answer_left(nlayers), answer_right(nlayers)
    integer(kind=i_def) :: spt_case(nlayers)

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set up a non-linear function
    rho(1,1) = 4.0_r_tran
    rho(1,2) = 1.0_r_tran
    rho(1,3) = 4.0_r_tran
    rho(1,4) = 10.0_r_tran
    rho(1,5) = 16.0_r_tran

    ! Test all points on same panel
    spt_case = 2_i_def
    answer_left  = 2.0_r_tran
    answer_right = 6.5_r_tran

    call nirvana_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test shifted left
    spt_case = 3_i_def
    answer_left  = 1.5_r_tran
    answer_right = 7.5_r_tran

    call nirvana_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test shifted right
    spt_case = 1_i_def
    answer_left  = 1.0_r_tran
    answer_right = 7.0_r_tran

    call nirvana_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine nirvana_special_edge_test

  !------------------------------------------------------------------

  @test
  subroutine linear_special_edge_test()
    use funit
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: linear_special_edge

    implicit none

    integer(kind=i_def), parameter :: nlayers = 1

    real(kind=r_tran)   :: rho(nlayers,3)
    real(kind=r_tran)   :: edge_left(nlayers), edge_right(nlayers), tol
    real(kind=r_tran)   :: answer_left(nlayers), answer_right(nlayers)
    integer(kind=i_def) :: spt_case(nlayers)

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set up a non-linear function
    rho(1,1) = 1.0_r_tran
    rho(1,2) = 4.0_r_tran
    rho(1,3) = 10.0_r_tran

    ! Test all points on same panel
    spt_case = 2_i_def
    answer_left  = 2.0_r_tran
    answer_right = 6.5_r_tran

    call linear_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test shifted left
    spt_case = 3_i_def
    answer_left  = 2.5_r_tran
    answer_right = 5.5_r_tran

    call linear_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test shifted right
    spt_case = 1_i_def
    answer_left  = 1.0_r_tran
    answer_right = 7.0_r_tran

    call linear_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine linear_special_edge_test

  !------------------------------------------------------------------

  @test
  subroutine fourth_order_special_edge_test()
    use funit
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: fourth_order_special_edge

    implicit none

    integer(kind=i_def), parameter :: nlayers = 1

    real(kind=r_tran)   :: rho(nlayers,7)
    real(kind=r_tran)   :: edge_left(nlayers), edge_right(nlayers), tol
    real(kind=r_tran)   :: answer_left(nlayers), answer_right(nlayers)
    integer(kind=i_def) :: spt_case(nlayers)

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set up a non-linear function
    rho(1,1) = 2.0_r_tran
    rho(1,2) = 3.0_r_tran
    rho(1,3) = 2.0_r_tran
    rho(1,4) = 1.0_r_tran
    rho(1,5) = 2.0_r_tran
    rho(1,6) = 3.0_r_tran
    rho(1,7) = 4.0_r_tran

    ! Test all points on same panel
    spt_case = 3_i_def
    answer_left  = 4.0_r_tran/3.0_r_tran
    answer_right = 4.0_r_tran/3.0_r_tran

    call fourth_order_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift left by 1
    spt_case = 5_i_def
    answer_left  = 4.0_r_tran/3.0_r_tran
    answer_right = 1.0_r_tran

    call fourth_order_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift left by 2
    spt_case = 4_i_def
    answer_left  = 4.0_r_tran/3.0_r_tran
    answer_right = 1.0_r_tran

    call fourth_order_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift right by 1
    spt_case = 1_i_def
    answer_left  = 1.0_r_tran
    answer_right = 4.0_r_tran/3.0_r_tran

    call fourth_order_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift right by 2
    spt_case = 2_i_def
    answer_left  = 0.5_r_tran
    answer_right = 1.5_r_tran

    call fourth_order_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine fourth_order_special_edge_test

  !------------------------------------------------------------------

  @test
  subroutine fourth_nirvana_special_edge_test()
    use funit
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: fourth_nirvana_special_edge

    implicit none

    integer(kind=i_def), parameter :: nlayers = 1

    real(kind=r_tran)   :: rho(nlayers,5)
    real(kind=r_tran)   :: edge_left(nlayers), edge_right(nlayers), tol
    real(kind=r_tran)   :: answer_left(nlayers), answer_right(nlayers)
    integer(kind=i_def) :: spt_case(nlayers)

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set up a non-linear function
    rho(1,1) = 4.0_r_tran
    rho(1,2) = 1.0_r_tran
    rho(1,3) = 4.0_r_tran
    rho(1,4) = 10.0_r_tran
    rho(1,5) = 16.0_r_tran

    ! Test all points on same panel
    spt_case = 3_i_def
    answer_left  = 1.75_r_tran
    answer_right = 6.75_r_tran

    call fourth_nirvana_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Do Nirvana edge
    spt_case = 5_i_def
    answer_left  = 2.0_r_tran
    answer_right = 6.5_r_tran

    call fourth_nirvana_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift left
    spt_case = 4_i_def
    answer_left  = 1.5_r_tran
    answer_right = 7.5_r_tran

    call fourth_nirvana_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift right
    spt_case = 2_i_def
    answer_left  = 1.0_r_tran
    answer_right = 7.0_r_tran

    call fourth_nirvana_special_edge(rho, spt_case, edge_left, edge_right, nlayers)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine fourth_nirvana_special_edge_test

  !------------------------------------------------------------------

end module subgrid_horizontal_support_mod_test
