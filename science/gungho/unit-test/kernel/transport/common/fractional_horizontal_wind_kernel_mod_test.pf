!-----------------------------------------------------------------------------
! (c) Crown copyright 2024 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Test the horizontal fractional wind computation

module fractional_horizontal_wind_kernel_mod_test

  use constants_mod, only : i_def, r_tran
  use funit

  implicit none

  private

  public :: test_all

  @TestCase
  type, public, extends(TestCase) :: fractional_horizontal_wind_test_type
    private
  contains
    procedure test_all
  end type fractional_horizontal_wind_test_type

contains

 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env,  only: real64
    use fractional_horizontal_wind_kernel_mod, only: fractional_horizontal_wind_code

    implicit none

    class(fractional_horizontal_wind_test_type), intent(inout) :: this

    real(kind=r_tran), parameter :: tol = 1.0e-12_r_tran   ! r_tran 64-bit
    real(kind=r_tran)            :: answer, use_tol

    ! DOF and stencil parameters
    integer(kind=i_def), parameter :: nlayers = 1
    integer(kind=i_def), parameter :: ndf_w3 = 1
    integer(kind=i_def), parameter :: ndf_w2 = 4
    integer(kind=i_def), parameter :: ndf_w3_2d = 1
    integer(kind=i_def), parameter :: stencil_size = 5
    integer(kind=i_def), parameter :: stencil_extent = 1
    integer(kind=i_def), parameter :: undf_w2 = ndf_w2*nlayers
    integer(kind=i_def), parameter :: undf_w3 = ndf_w3*nlayers*stencil_size
    integer(kind=i_def), parameter :: undf_w3_2d = ndf_w3_2d

    ! Maps
    integer(kind=i_def), dimension(ndf_w3_2d)           :: map_w3_2d
    integer(kind=i_def), dimension(ndf_w3)              :: map_w3
    integer(kind=i_def), dimension(ndf_w2)              :: map_w2
    integer(kind=i_def), dimension(ndf_w3,stencil_size) :: stencil_map

    ! Fields
    real(kind=r_tran),   dimension(undf_w2)    :: dep_dist_xy
    real(kind=r_tran),   dimension(undf_w2)    :: frac_wind_xy
    real(kind=r_tran),   dimension(undf_w3)    :: detj
    integer(kind=i_def), dimension(undf_w3_2d) :: face_selector_ew
    integer(kind=i_def), dimension(undf_w3_2d) :: face_selector_ns

    ! Set up maps
    stencil_map(1,:) = (/ 1, 2, 3, 4, 5 /)
    map_w2(:) = (/ 1, 2, 3, 4 /)
    map_w3(1) = 1
    map_w3_2d(1) = 1

    ! Set Det(J)
    detj(:) = (/ 2.0_r_tran, 4.0_r_tran, 5.0_r_tran, &
                  20.0_r_tran, 40.0_r_tran  /)

    ! Face selector: do all faces
    face_selector_ew(1) = 2
    face_selector_ns(1) = 2

    ! Negative winds -----------------------------------------------------------
    dep_dist_xy(:) = (/ -2.2_r_tran,-1.3_r_tran, -1.4_r_tran, -2.5_r_tran  /)

    ! Initialise dep_wind to zero before each test
    frac_wind_xy(:) = 0.0_r_tran

    call fractional_horizontal_wind_code( nlayers,          &
                                          frac_wind_xy,     &
                                          dep_dist_xy,      &
                                          detj,             &
                                          stencil_size,     &
                                          stencil_map,      &
                                          face_selector_ew, &
                                          face_selector_ns, &
                                          ndf_w2,           &
                                          undf_w2,          &
                                          map_w2,           &
                                          ndf_w3,           &
                                          undf_w3,          &
                                          map_w3,           &
                                          ndf_w3_2d,        &
                                          undf_w3_2d,       &
                                          map_w3_2d )

    ! Get correct tolerance
    if ( r_tran == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_tran*spacing( maxval( frac_wind_xy(1:4) ) )
    end if
    ! Answers are fractional part of departure distance, multiplied by volume
    ! of upwind cell
    answer = -0.2_r_tran*2.0_r_tran
    @assertEqual(answer, frac_wind_xy(1), use_tol)
    answer = -0.3_r_tran*5.0_r_tran
    @assertEqual(answer, frac_wind_xy(2), use_tol)
    answer = -0.4_r_tran*20.0_r_tran
    @assertEqual(answer, frac_wind_xy(3), use_tol)
    answer = -0.5_r_tran*2.0_r_tran
    @assertEqual(answer, frac_wind_xy(4), use_tol)

    ! Positive winds -----------------------------------------------------------
    dep_dist_xy(:) = (/ 2.2_r_tran, 1.3_r_tran, 1.4_r_tran, 2.5_r_tran  /)

    ! Initialise dep_wind to zero before each test
    frac_wind_xy(:) = 0.0_r_tran

    call fractional_horizontal_wind_code( nlayers,          &
                                          frac_wind_xy,     &
                                          dep_dist_xy,      &
                                          detj,             &
                                          stencil_size,     &
                                          stencil_map,      &
                                          face_selector_ew, &
                                          face_selector_ns, &
                                          ndf_w2,           &
                                          undf_w2,          &
                                          map_w2,           &
                                          ndf_w3,           &
                                          undf_w3,          &
                                          map_w3,           &
                                          ndf_w3_2d,        &
                                          undf_w3_2d,       &
                                          map_w3_2d )

    ! Answers are fractional part of departure distance, multiplied by volume
    ! of upwind cell
    answer = 0.2_r_tran*4.0_r_tran
    @assertEqual(answer, frac_wind_xy(1), use_tol)
    answer = 0.3_r_tran*2.0_r_tran
    @assertEqual(answer, frac_wind_xy(2), use_tol)
    answer = 0.4_r_tran*2.0_r_tran
    @assertEqual(answer, frac_wind_xy(3), use_tol)
    answer = 0.5_r_tran*40.0_r_tran
    @assertEqual(answer, frac_wind_xy(4), use_tol)

  end subroutine test_all

end module fractional_horizontal_wind_kernel_mod_test
