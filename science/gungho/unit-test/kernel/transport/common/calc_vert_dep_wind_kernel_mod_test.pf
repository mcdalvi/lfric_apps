!-----------------------------------------------------------------------------
! (c) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Test the vertical departure wind computation

module calc_vert_dep_wind_kernel_mod_test

  use constants_mod, only : i_def, r_tran
  use funit

  implicit none

  private

  public :: test_all

  @TestCase
  type, public, extends(TestCase) :: calc_vert_dep_wind_test_type
    private
  contains
    procedure test_all
  end type calc_vert_dep_wind_test_type

contains

 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env,  only: real64
    use calc_vert_dep_wind_kernel_mod,  only: calc_vert_dep_wind_code

    implicit none

    class(calc_vert_dep_wind_test_type), intent(inout) :: this

    real(kind=r_tran), parameter :: tol = 1.0e-12_r_tran   ! r_tran 64-bit
    real(kind=r_tran)            :: answer, use_tol

    ! DOF and stencil parameters
    integer(kind=i_def), parameter :: nlayers = 5
    integer(kind=i_def), parameter :: ndf_w3  = 1
    integer(kind=i_def), parameter :: ndf_w2  = 6
    integer(kind=i_def), parameter :: ndf_w2v = 2
    integer(kind=i_def), parameter :: undf_w2  = (ndf_w2-1)*nlayers+1
    integer(kind=i_def), parameter :: undf_w2v = (ndf_w2v-1)*nlayers+1
    integer(kind=i_def), parameter :: undf_w3  = ndf_w3*nlayers

    ! Maps
    integer(kind=i_def), dimension(ndf_w3)  :: map_w3
    integer(kind=i_def), dimension(ndf_w2)  :: map_w2
    integer(kind=i_def), dimension(ndf_w2v) :: map_w2v

    ! Fields
    real(kind=r_tran), dimension(undf_w2)  :: adv_wind
    real(kind=r_tran), dimension(undf_w2v) :: dep_wind
    real(kind=r_tran), dimension(undf_w3)  :: detj

    ! Set up maps
    map_w2(:) = (/ 1, 6, 11, 16, 21, 22 /)
    map_w2v(:) = (/ 1, 2 /)
    map_w3(1) = 1

    ! Set Det(J) for each layer
    detj(:) = (/ 1.0_r_tran, 2.0_r_tran, 4.0_r_tran, &
                  8.0_r_tran, 16.0_r_tran  /)

    ! For the advecting wind we only needs verital DOFs, so set others to zero
    adv_wind(:) = 0.0_r_tran

    ! Set positive vertical advecting wind at interior vertical faces
    adv_wind(22) = 16.0_r_tran
    adv_wind(23) = 16.0_r_tran
    adv_wind(24) = 16.0_r_tran
    adv_wind(25) = 16.0_r_tran

    ! Initialise dep_wind to zero before each test
    dep_wind(:) = 0.0_r_tran

    call calc_vert_dep_wind_code( nlayers,      &
                                  dep_wind,     &
                                  adv_wind,     &
                                  detj,         &
                                  ndf_w2v,      &
                                  undf_w2v,     &
                                  map_w2v,      &
                                  ndf_w2,       &
                                  undf_w2,      &
                                  map_w2,       &
                                  ndf_w3,       &
                                  undf_w3,      &
                                  map_w3 )

    ! Get correct tolerance
    if ( r_tran == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_tran*spacing( maxval( dep_wind(:) ) )
    end if
    answer = 0.0_r_tran
    @assertEqual(answer, dep_wind(1), use_tol)
    answer = 16.0_r_tran
    @assertEqual(answer, dep_wind(2), use_tol)
    answer = 8.0_r_tran
    @assertEqual(answer, dep_wind(3), use_tol)
    answer = 4.0_r_tran
    @assertEqual(answer, dep_wind(4), use_tol)
    answer = 2.0_r_tran
    @assertEqual(answer, dep_wind(5), use_tol)
    answer = 0.0_r_tran
    @assertEqual(answer, dep_wind(6), use_tol)

    ! Set negative vertical advecting wind at interior vertical faces
    adv_wind(22) = -16.0_r_tran
    adv_wind(23) = -16.0_r_tran
    adv_wind(24) = -16.0_r_tran
    adv_wind(25) = -16.0_r_tran

    ! Initialise dep_wind to zero before each test
    dep_wind(:) = 0.0_r_tran

    call calc_vert_dep_wind_code( nlayers,      &
                                  dep_wind,     &
                                  adv_wind,     &
                                  detj,         &
                                  ndf_w2v,      &
                                  undf_w2v,     &
                                  map_w2v,      &
                                  ndf_w2,       &
                                  undf_w2,      &
                                  map_w2,       &
                                  ndf_w3,       &
                                  undf_w3,      &
                                  map_w3 )

    ! Get correct tolerance
    if ( r_tran == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_tran*spacing( maxval( dep_wind(:) ) )
    end if
    answer = 0.0_r_tran
    @assertEqual(answer, dep_wind(1), use_tol)
    answer = -8.0_r_tran
    @assertEqual(answer, dep_wind(2), use_tol)
    answer = -4.0_r_tran
    @assertEqual(answer, dep_wind(3), use_tol)
    answer = -2.0_r_tran
    @assertEqual(answer, dep_wind(4), use_tol)
    answer = -1.0_r_tran
    @assertEqual(answer, dep_wind(5), use_tol)
    answer = 0.0_r_tran
    @assertEqual(answer, dep_wind(6), use_tol)

  end subroutine test_all

end module calc_vert_dep_wind_kernel_mod_test
