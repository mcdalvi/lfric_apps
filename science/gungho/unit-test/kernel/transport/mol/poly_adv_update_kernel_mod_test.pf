!-----------------------------------------------------------------------------
! (C) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the computation of the 1d horiztonal advective update
module poly_adv_update_kernel_mod_test

  use constants_mod, only: i_def, r_def
  use funit

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: poly_adv_update_test_type
    private
  contains
    procedure test_all
  end type poly_adv_update_test_type

contains

  @Test
  subroutine test_all( this )

    use poly_adv_update_kernel_mod, only: poly_adv_update_code

    implicit none

    class(poly_adv_update_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def
    real(r_def)            :: answer

    integer(i_def), parameter         :: nlayers = 1
    integer(i_def), parameter         :: ndf_wt  = 2
    integer(i_def), parameter         :: ndf_w2  = 4
    integer(i_def), parameter         :: ndf_md  = 1
    integer(i_def), parameter         :: undf_wt = nlayers+1
    integer(i_def), parameter         :: undf_w2 = (ndf_w2*nlayers)*5
    integer(i_def), parameter         :: undf_md = (4*(nlayers+1))*5
    integer(i_def), dimension(ndf_wt) :: map_wt
    integer(i_def), dimension(ndf_md) :: map_md
    integer(i_def), dimension(ndf_w2) :: map_w2

    integer(i_def), dimension(4)                      :: smap_md_size
    integer(i_def), parameter                         :: smap_md_max = 2
    integer(i_def), dimension(ndf_md, smap_md_max, 4) :: smap_md
    integer(i_def), dimension(4)                      :: smap_w2_size
    integer(i_def), parameter                         :: smap_w2_max = 2
    integer(i_def), dimension(ndf_w2, smap_w2_max, 4) :: smap_w2

    real(r_def), dimension(undf_wt) :: advective
    real(r_def), dimension(undf_md) :: tracer
    real(r_def), dimension(undf_w2) :: wind
    real(r_def), dimension(undf_w2) :: wind_dir

    integer(i_def) :: df, k

    real(r_def), parameter :: u0 = 1.0_r_def

    map_wt(:) = (/ 1, 2 /)
    do df = 1,ndf_w2
      map_w2(df) = 1 + (df-1)*nlayers
    end do
    map_md(1) = 1

    ! Stencil maps
    smap_md_size(:) = 2
    do k = 1, 4
      smap_md(:,1,k) =  map_md(:)
      smap_md(:,2,k) =  map_md(:) + k*(4*ndf_md*(nlayers+1))
    end do

    smap_w2_size(:) = 2
    smap_w2(:,2,:) = -1
    do k = 1, 4
      smap_w2(:,1,k) =  map_w2(:)
    end do
    smap_w2(3,2,1) = map_w2(1)
    smap_w2(4,2,2) = map_w2(2)
    smap_w2(1,2,3) = map_w2(3)
    smap_w2(2,2,4) = map_w2(4)

    wind(:) = u0
    wind_dir(:) = wind(:)

    do df = 1,undf_md
      tracer(df) = 300.0_r_def + real(df,r_def)
    end do

    call poly_adv_update_code( nlayers,      &
                               advective,    &
                               tracer,       &
                               smap_md_size, &
                               smap_md_max,  &
                               smap_md,      &
                               wind,         &
                               wind_dir,     &
                               smap_w2_size, &
                               smap_w2_max,  &
                               smap_w2,      &
                               ndf_wt,       &
                               undf_wt,      &
                               map_wt,       &
                               ndf_md,       &
                               undf_md,      &
                               map_md,       &
                               ndf_w2,       &
                               undf_w2,      &
                               map_w2        &
                             )

    do k = 0,nlayers - 1
      answer = 0.5_r_def*u0*(tracer(map_md(1)     +2*(nlayers+1)+k)  &
                           - tracer(smap_md(1,2,1)+2*(nlayers+1)+k)) &
             - 0.5_r_def*u0*(tracer(smap_md(1,2,4)+1*(nlayers+1)+k)  &
                           - tracer(map_md(1)     +1*(nlayers+1)+k))

      @assertEqual(answer, advective(map_wt(1)+k), tol)
    end do

  end subroutine test_all

end module poly_adv_update_kernel_mod_test
