!-----------------------------------------------------------------------------
! (C) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the horizontal edge_values computed for a wtheta-field using the Koren scheme
module polyh_wtheta_koren_kernel_mod_test

  use constants_mod, only : i_def, l_def, r_tran
  use funit

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: polyh_wtheta_koren_test_type
    private
  contains
    procedure test_all
  end type polyh_wtheta_koren_test_type

contains

  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env, only: real64
    use polyh_wtheta_koren_kernel_mod, only: polyh_wtheta_koren_code

    implicit none

    class(polyh_wtheta_koren_test_type), intent(inout) :: this

    real(r_tran), parameter :: tol = 1.0e-12_r_tran
    real(r_tran)            :: answer, use_tol

    integer(i_def), parameter                      :: nlayers = 3
    integer(i_def), parameter                      :: ndf_md = 1
    integer(i_def), parameter                      :: ndf_wt = 2
    integer(i_def), parameter                      :: ndf_c  = 2
    integer(i_def), parameter                      :: nfaces_h = 4
    integer(i_def), parameter                      :: undf_md = 4*ndf_md*(nlayers+1)
    integer(i_def), dimension(ndf_md)              :: map_md
    integer(i_def), parameter                      :: stencil_size = 5
    integer(i_def), dimension(ndf_wt,stencil_size) :: stencil_map
    integer(i_def), parameter                      :: undf_wt = (nlayers+1)*stencil_size
    integer(i_def), parameter                      :: order = 2
    integer(i_def), parameter                      :: ndata = (order+1)*nfaces_h
    integer(i_def), parameter                      :: undf_c = ndata*(nlayers+1)

    real(r_tran), dimension(undf_md)  :: reconstruction
    real(r_tran), dimension(undf_wt)  :: tracer

    integer(i_def) :: i

    map_md(1) = 1
    do i = 1,stencil_size
      stencil_map(1,i) = 1 + (i-1)*(nlayers+1)
      stencil_map(2,i) = 2 + (i-1)*(nlayers+1)
    end do

    ! Set up tracer field so that d(tracer)/dx = 10
    tracer(:) = 300.0_r_tran
    do i = 0,nlayers
      tracer(stencil_map(1,1)+i) = 300.0_r_tran
      tracer(stencil_map(1,2)+i) = 290.0_r_tran
      tracer(stencil_map(1,4)+i) = 310.0_r_tran
    end do
   reconstruction = 0.0_r_tran

    reconstruction = 0.0_r_tran

    call polyh_wtheta_koren_code( nlayers,        &
                                  reconstruction, &
                                  tracer,         &
                                  stencil_size,   &
                                  stencil_map,    &
                                  ndf_md,         &
                                  undf_md,        &
                                  map_md,         &
                                  ndf_wt,         &
                                  undf_wt,        &
                                  stencil_map(:,1) )

   if ( r_tran == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_tran*spacing(maxval(reconstruction))
    end if
    answer = 295.0_r_tran
    do i = 1,nlayers
      @assertEqual(answer, reconstruction(map_md(1)+i), use_tol)
    end do
    answer = 305.0_r_tran
    do i = 1,nlayers
      @assertEqual(answer, reconstruction(map_md(1)+i+2*(nlayers+1)), use_tol)
    end do

  end subroutine test_all

end module polyh_wtheta_koren_kernel_mod_test
