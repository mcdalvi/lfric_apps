!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Test the theta_e_kernel
module theta_e_kernel_mod_test

  use, intrinsic :: iso_fortran_env,       only : real64
  use constants_mod,                       only : i_def, r_def
  use funit

  implicit none

  private
  public :: theta_e_test_type, test_all

  @TestCase
  type, extends(TestCase) :: theta_e_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type theta_e_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(theta_e_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(theta_e_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use theta_e_kernel_mod, only : theta_e_code

   implicit none

    class(theta_e_test_type), intent(inout) :: this

    real(kind=r_def),      parameter :: theta0 = 10.0_r_def
    real(kind=r_def),      parameter :: dtheta = 0.001_r_def
    real(kind=r_def),      parameter :: Lv = 2.501e6_r_def
    real(kind=r_def),      parameter :: cpd = 1000.0_r_def
    real(kind=r_def),      parameter :: cpv = 0.0_r_def
    real(kind=r_def),      parameter :: cpl = 0.0_r_def
    real(kind=r_def),      parameter :: p_zero = 100000.0_r_def
    real(kind=r_def),      parameter :: Rd = 287.0_r_def
    real(kind=r_def),      parameter :: Rv = 461.5_r_def
    real(kind=r_def),      parameter :: recip_epsilon = Rd / Rv
    real(kind=r_def),      parameter :: tol = 1.0_r_def
    real(kind=r_def)                 :: use_tol
    integer(kind=i_def),   parameter :: undf_wt = 10
    integer(kind=i_def)              :: df

    ! Fields
    real(kind=r_def),    allocatable :: theta_e(:)
    real(kind=r_def),    allocatable :: theta_d(:)
    real(kind=r_def),    allocatable :: exner_at_wt(:)
    real(kind=r_def),    allocatable :: mr_v(:)
    real(kind=r_def),    allocatable :: mr_cl(:)
    real(kind=r_def),    allocatable :: answer(:)


    ! Create the data
    allocate( mr_v( undf_wt ) )
    allocate( mr_cl( undf_wt ) )
    allocate( exner_at_wt( undf_wt ) )
    allocate( theta_d( undf_wt ) )
    allocate( theta_e( undf_wt ) )
    allocate( answer( undf_wt ) )

    mr_cl(:) = 0.0_r_def

    do df = 1, undf_wt
      answer(df) = exp( theta0 + dtheta * real(df, r_def) )
      ! Use that ln(theta_e) = ln(theta_d) + L_v*mr_v/(cp*theta_d*Pi)
      ! Also have theta_d vary linearly height in log space
      theta_d(df) = exp( theta0 + dtheta / 2.0_r_def * real(df, r_def) )
      ! Non-log term must make half of contribution to ln(theta_e)
      ! Take Pi = 1/theta_d, so this comes from mr_v
      exner_at_wt(df) = 1.0_r_def / theta_d(df)
      mr_v(df) = dtheta / 2.0_r_def * real(df, r_def) * cpd / Lv
    end do

    ! Make theta_e initially have wrong values
    theta_e(:) = 0.0_r_def

    do df = 1, undf_wt
      call theta_e_code( theta_e(df),       &
                         theta_d(df),       &
                         exner_at_wt(df),   &
                         mr_v(df),          &
                         mr_cl(df),         &
                         cpd,               &
                         cpv,               &
                         cpl,               &
                         Rd,                &
                         p_zero,            &
                         recip_epsilon)
    end do

    if ( r_def == real64 ) then
       use_tol = tol
    else
       use_tol = 10.0_r_def*spacing( maxval(answer) )
    end if

    ! Slack tolerance because answer is only approximate
    @assertEqual(answer, theta_e, use_tol)

    deallocate( answer )
    deallocate( theta_e )
    deallocate( theta_d )
    deallocate( mr_v )
    deallocate( mr_cl )
    deallocate( exner_at_wt )

  end subroutine test_all

end module theta_e_kernel_mod_test
