!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Initialises, steps and finalises the adjoint model (semi-implicit).

module adjoint_model_mod

  use atl_si_timestep_alg_mod,       only : atl_si_timestep_type
  use field_array_mod,               only : field_array_type
  use field_collection_mod,          only : field_collection_type
  use field_mod,                     only : field_type
  use driver_modeldb_mod,            only : modeldb_type
  use log_mod,                       only : log_event, log_scratch_space, &
                                            LOG_LEVEL_ERROR, LOG_LEVEL_INFO, &
                                            LOG_LEVEL_TRACE
  use model_clock_mod,               only : model_clock_type
  use moisture_conservation_alg_mod, only : moisture_conservation_alg
  use timestepping_config_mod,       only : method, method_semi_implicit

  implicit none

  private

  public initialise_adjoint_model, adjoint_step, finalise_adjoint_model

contains

  !> @brief Completes the initialisation of the adjoint model
  !> @param[in,out] modeldb         The working data set for the model run
  !> @param[in]     atl_si_timestep Object encapsulating adjoint step routines
  subroutine initialise_adjoint_model( modeldb, atl_si_timestep )

    implicit none

    ! Arguments
    type(modeldb_type),         intent(inout), target  :: modeldb
    type(atl_si_timestep_type), intent(inout)          :: atl_si_timestep

    ! Local variables
    type(field_collection_type), pointer :: prognostic_fields
    type(field_type),            pointer :: mr(:)
    type(field_collection_type), pointer :: ls_fields
    type(field_type),            pointer :: ls_mr(:)
    type(field_type),            pointer :: ls_moist_dyn(:)

    type(field_type), pointer :: theta
    type(field_type), pointer :: u
    type(field_type), pointer :: rho
    type(field_type), pointer :: exner
    type(field_type), pointer :: ls_theta
    type(field_type), pointer :: ls_u
    type(field_type), pointer :: ls_rho
    type(field_type), pointer :: ls_exner

    type(field_collection_type), pointer :: moisture_fields
    type(field_array_type),      pointer :: mr_array
    type(field_array_type),      pointer :: ls_mr_array
    type(field_array_type),      pointer :: ls_moist_dyn_array

    ! Get pointers to field collections for use downstream
    prognostic_fields => &
      modeldb%fields%get_field_collection("prognostic_fields")
    moisture_fields   => modeldb%fields%get_field_collection("moisture_fields")

    call moisture_fields%get_field( "mr", mr_array )
    call moisture_fields%get_field( "ls_mr", ls_mr_array )
    call moisture_fields%get_field( "ls_moist_dyn", ls_moist_dyn_array )

    mr           => mr_array%bundle
    ls_mr        => ls_mr_array%bundle
    ls_moist_dyn => ls_moist_dyn_array%bundle
    ls_fields    => modeldb%fields%get_field_collection("ls_fields")

    ! Get pointers to fields in the prognostic/diagnostic field collections
    call prognostic_fields%get_field( 'theta', theta )
    call prognostic_fields%get_field( 'u', u )
    call prognostic_fields%get_field( 'rho', rho )
    call prognostic_fields%get_field( 'exner', exner )
    call ls_fields%get_field( 'ls_theta', ls_theta )
    call ls_fields%get_field( 'ls_u', ls_u )
    call ls_fields%get_field( 'ls_rho', ls_rho )
    call ls_fields%get_field( 'ls_exner', ls_exner )

    select case(method)
      case(method_semi_implicit)
        call atl_si_timestep%initialise( &
          u, rho, theta, exner, mr, ls_theta, ls_exner, ls_mr, ls_moist_dyn )
      case default
        call log_event( "Timestepping method not available for adjoint", &
                        LOG_LEVEL_ERROR )
    end select

  end subroutine initialise_adjoint_model

  !> @brief Steps the adjoint model through one (semi-implicit) timestep
  !> @param[in,out] modeldb         The working data set for the model run
  !> @param[in]     atl_si_timestep Object encapsulating adjoint step routines
  subroutine adjoint_step( modeldb, atl_si_timestep )

    implicit none

    ! Arguments
    type(modeldb_type),         intent(inout), target  :: modeldb
    type(atl_si_timestep_type), intent(inout)          :: atl_si_timestep

    ! Local variables
    type(field_collection_type), pointer :: prognostic_fields
    type(field_type),            pointer :: mr(:)
    type(field_type),            pointer :: moist_dyn(:)
    type(field_collection_type), pointer :: derived_fields
    type(field_collection_type), pointer :: ls_fields
    type(field_type),            pointer :: ls_mr(:)
    type(field_type),            pointer :: ls_moist_dyn(:)

    type(field_type), pointer :: theta
    type(field_type), pointer :: u
    type(field_type), pointer :: rho
    type(field_type), pointer :: exner
    type(field_type), pointer :: ls_theta
    type(field_type), pointer :: ls_u
    type(field_type), pointer :: ls_rho
    type(field_type), pointer :: ls_exner

    type(field_collection_type), pointer :: moisture_fields
    type(field_array_type),      pointer :: mr_array
    type(field_array_type),      pointer :: moist_dyn_array
    type(field_array_type),      pointer :: ls_mr_array
    type(field_array_type),      pointer :: ls_moist_dyn_array

    write( log_scratch_space, '(A,I0)' ) 'Start of adjoint timestep ', &
                                         modeldb%clock%get_step()
    call log_event( log_scratch_space, LOG_LEVEL_INFO )

    ! Get pointers to field collections for use downstream
    prognostic_fields => &
      modeldb%fields%get_field_collection("prognostic_fields")
    moisture_fields   => modeldb%fields%get_field_collection("moisture_fields")
    ls_fields         => modeldb%fields%get_field_collection("ls_fields")

    call moisture_fields%get_field( "mr", mr_array )
    call moisture_fields%get_field( "moist_dyn", moist_dyn_array )
    call moisture_fields%get_field( "ls_mr", ls_mr_array )
    call moisture_fields%get_field( "ls_moist_dyn", ls_moist_dyn_array )

    mr             => mr_array%bundle
    moist_dyn      => moist_dyn_array%bundle
    derived_fields => modeldb%fields%get_field_collection("derived_fields")
    ls_mr        => ls_mr_array%bundle
    ls_moist_dyn => ls_moist_dyn_array%bundle

    ! Get pointers to fields in the prognostic/LS field collections
    call prognostic_fields%get_field( 'theta', theta )
    call prognostic_fields%get_field( 'u', u )
    call prognostic_fields%get_field( 'rho', rho )
    call prognostic_fields%get_field( 'exner', exner )
    call ls_fields%get_field( 'ls_theta', ls_theta )
    call ls_fields%get_field( 'ls_u', ls_u )
    call ls_fields%get_field( 'ls_rho', ls_rho )
    call ls_fields%get_field( 'ls_exner', ls_exner )

    call atl_si_timestep%step( modeldb, u, rho, theta, exner, mr, moist_dyn, &
                               ls_u, ls_rho, ls_theta, ls_exner, ls_mr, &
                               ls_moist_dyn )

    write( log_scratch_space, '(A,I0)' ) 'End of adjoint timestep ', &
                                         modeldb%clock%get_step()
    call log_event( log_scratch_space, LOG_LEVEL_INFO )

  end subroutine adjoint_step

  !> @brief Finalises remaining infrastructure and constants used by adjoint
  !> @param[in] atl_si_timestep Object encapsulating the adjoint timestep routines
  subroutine finalise_adjoint_model(atl_si_timestep)

    implicit none

    ! Arguments
    type(atl_si_timestep_type), intent(inout) :: atl_si_timestep

    call atl_si_timestep%finalise()

  end subroutine finalise_adjoint_model

end module adjoint_model_mod
