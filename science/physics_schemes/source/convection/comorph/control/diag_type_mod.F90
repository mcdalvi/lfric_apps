! *****************************COPYRIGHT*******************************
! (C) Crown copyright Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
! *****************************COPYRIGHT*******************************

! Code Owner: Please refer to the UM file CodeOwners.txt
! This file belongs in section: convection_comorph

module diag_type_mod

use comorph_constants_mod, only: real_hmprec, name_length

implicit none


!----------------------------------------------------------------
! Type definition for flags for each possible domain profile a
! comorph diagnostic field can have
!----------------------------------------------------------------
! Currently 4 options:
type :: dom_type

  ! 2-D on x,y domain
  logical :: x_y = .false.

  ! On x,y domain with a separate field for each
  ! updraft or downdraft type (so 3-D)
  logical :: x_y_typ = .false.

  ! On x,y domain with a separate field for each
  ! updraft or downdraft type and layer (so 4-D)
  logical :: x_y_lay_typ = .false.

  ! 3-D on x,y,z domain
  logical :: x_y_z = .false.

  ! On x,y,z domain with a separate field for each
  ! updraft or downdraft type (so 4-D)
  logical :: x_y_z_typ = .false.

  ! On x,y,z domain with a separate field for each
  ! updraft or downdraft type and layer (so 5-D)
  logical :: x_y_z_lay_typ = .false.

end type dom_type


!----------------------------------------------------------------
! Type definition for a diagnostic
!----------------------------------------------------------------
type :: diag_type


  ! Fields set by the calling routine before calling comorph_ctl:

  ! Pointers to the array in which the diag is to be output,
  ! for various different possible ranks; 2-D, 3-D, 4-D, 5-D
  real(kind=real_hmprec), pointer :: field_2d(:,:) => null()
  real(kind=real_hmprec), pointer :: field_3d(:,:,:) => null()
  real(kind=real_hmprec), pointer :: field_4d(:,:,:,:) => null()
  real(kind=real_hmprec), pointer :: field_5d(:,:,:,:,:) => null()
  ! Note: some diagnostics can be output in more than one
  ! rank at once, e.g. parcel properties can be 4-D if output
  ! separately for each convection type, and 3-D if output
  ! as a mean over all convection types.

  ! Flags for whether the diagnostic is requested in each of
  ! the allowed domain profiles (see dom_type definition above)
  type(dom_type) :: request
  ! Note: as described above, some diags can be output on
  ! more than one of the allowed domain profiles at once.


  ! Fields set internally by the CoMorph diagnostic system:

  ! Name of the diagnostic (autogenerated by the diag system).
  character(len=name_length) :: diag_name

  ! Flag for whether it is requested for output in any rank
  logical :: l_req = .false.

  ! Flag for whether it needs to be calculated and stored in
  ! the diagnostics super-array.
  ! (even if not requested for output, it might be needed for
  !  calculating another diagnostic which depends on it)
  logical :: flag = .false.

  ! Field indicator; to map to address in field or parcel
  ! super-arrays
  integer :: i_field = 0

  ! Address of this field in compressed diagnostics super-array
  integer :: i_super = 0


end type diag_type


!----------------------------------------------------------------
! Type definition for a list of pointers to all active diags
!----------------------------------------------------------------
! (only those which have a request flag set to true on input)
! Contains a pointer to one of the above diag structures
type :: diag_list_type
  type(diag_type), pointer :: pt => null()
end type diag_list_type


contains


!----------------------------------------------------------------
! Subroutine to set the various internal properties (meta-data)
! in a diag_type structure, and assign a pointer from a diag_list
! to point at it.
!----------------------------------------------------------------
! This routine also checks that the flags and pointers set for
! the diagnostic on input to CoMorph are self-consistent,
! and raises an error if they aren't.
! Note: this routine gets called twice for each diagnostic
!   1st call (l_count_diags = .true.):
!     Check whether diag is requested and increment the count
!     for number of requested diags if it is.
!   2nd call (l_count_diags = .false.):
!     Set other properties for requested diags, and assign
!     pointer from active diags list.
subroutine diag_assign( diag_name, l_count_diags, doms, diag, list,            &
                        i_diag, i_super, i_field )

use comorph_constants_mod, only: name_length, newline
use raise_error_mod, only: raise_fatal

implicit none

! Name of the diagnostic
character(len=name_length), intent(in) :: diag_name

! Flag for 1st call to this routine, in which we just check
! whether the diag is requested and count up number requested
logical, intent(in) :: l_count_diags

! Structure containing the allowed domain profiles for this diag
type(dom_type), intent(in) :: doms

! Structure for the current diagnostic
type(diag_type), target, intent(in out) :: diag

! Output diagnostic list to assign to (not used on first sweep).
! Set to contain a list of pointers to all requested diagnostics.
type(diag_list_type), intent(in out) :: list(:)

! Counter for requested diagnostics in the local list
integer, intent(in out) :: i_diag

! Address in compressed super-array
integer, intent(in out) :: i_super

! Field indicator (only applies for certain diagnostics)
integer, optional, intent(in) :: i_field

! Local error flag
logical :: l_error

character(len=*), parameter :: routinename = "DIAG_ASSIGN"


! Only on first call:
if ( l_count_diags ) then

  ! Initialise error flag
  l_error = .false.

  ! Check if the diag has been requested in each domain profile,
  ! setting error flag if requested for a domain profile
  ! which is not available for this diag...

  if ( diag % request % x_y ) then
    diag%l_req = .true.
    if ( .not. doms % x_y ) l_error = .true.
  end if
  if ( diag % request % x_y_typ ) then
    diag%l_req = .true.
    if ( .not. doms % x_y_typ ) l_error = .true.
  end if
  if ( diag % request % x_y_lay_typ ) then
    diag%l_req = .true.
    if ( .not. doms % x_y_lay_typ ) l_error = .true.
  end if

  if ( diag % request % x_y_z ) then
    diag%l_req = .true.
    if ( .not. doms % x_y_z ) l_error = .true.
  end if
  if ( diag % request % x_y_z_typ ) then
    diag%l_req = .true.
    if ( .not. doms % x_y_z_typ ) l_error = .true.
  end if
  if ( diag % request % x_y_z_lay_typ ) then
    diag%l_req = .true.
    if ( .not. doms % x_y_z_lay_typ ) l_error = .true.
  end if

  ! If requested on any domain profile
  if ( diag%l_req ) then

    ! Print error if problem found
    if ( l_error ) then
      call raise_fatal( routinename,                                           &
             "Diagnostic " // trim(adjustl(diag_name)) // " "      //          &
             "has been requested on a domain "       //newline//               &
             "profile on which it is not available." )
    else
      ! If no problem, set flag to calculate and store the diag.
      diag%flag = .true.
    end if

  end if

end if  ! ( l_count_diags )


! Both calls; increment counter for requested diagnostics.
if ( diag%l_req )  i_diag = i_diag + 1


! Only on 2nd call:
if ( .not. l_count_diags ) then

  ! If diag is requested (or needed for computing other diags)
  if ( diag%flag ) then

    ! Give the diagnostic its name (traditional coming-of-age
    ! ceremony begins here)
    diag % diag_name = diag_name

    ! Increment the super-array address counter and assign it
    i_super = i_super + 1
    diag % i_super = i_super

    ! Label the field using the input field indicator, if present
    if ( present(i_field) ) then
      diag % i_field = i_field
      ! Fail if i_field is present but is zero;
      ! this indicates a diag has been requested for a field
      ! which is not in use
      if ( i_field == 0 ) then
        call raise_fatal( routinename,                                         &
          "Diagnostic " // trim(adjustl(diag_name)) // " "         //          &
          "has been requested but corresponds to a " //newline//               &
          "field which is not in use." )
      end if
    end if

    ! If diag is requested for output, point the next element
    ! of the output diags list to the current diag structure
    if ( diag%l_req )  list(i_diag)%pt => diag

  end if

end if  ! ( .not. l_count_diags )


return
end subroutine diag_assign


end module diag_type_mod
