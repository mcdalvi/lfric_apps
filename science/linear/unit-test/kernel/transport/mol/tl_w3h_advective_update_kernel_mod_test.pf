!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Test the horizontal advective wind update computation
module tl_w3h_advective_update_kernel_mod_test

  use, intrinsic :: iso_fortran_env, only : real64, real32
  use constants_mod,                 only : i_def, r_def
  use funit

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: tl_w3h_advective_update_test_type
    private
  contains
    procedure test_all
  end type tl_w3h_advective_update_test_type

contains

  @test
  subroutine test_all( this )

    use tl_w3h_advective_update_kernel_mod, only : tl_w3h_advective_update_code

    implicit none

    class(tl_w3h_advective_update_test_type), intent(inout) :: this

    real(kind=r_def) :: tol
    real(kind=r_def) :: answer

    ! Mesh
    integer(kind=i_def), parameter :: nlayers = 2
    integer(kind=i_def), parameter :: ncell_3d = nlayers
    integer(kind=i_def), parameter :: cell = 1
    ! Scalar Space
    integer(kind=i_def), parameter                           :: ndf_ws = 1_i_def
    integer(kind=i_def), parameter                           :: undf_ws = ndf_ws*nlayers
    integer(kind=i_def), dimension(ndf_ws)                   :: map_ws
    real(kind=r_def),    dimension(undf_ws)                  :: advective_update
    real(kind=r_def),    dimension(ndf_ws, ndf_ws, ncell_3d) :: m3_inv
    ! Vector Space
    integer(kind=i_def), parameter                         :: ndf_wv  = 4_i_def
    integer(kind=i_def), parameter                         :: undf_wv = ndf_wv*nlayers
    integer(kind=i_def), dimension(ndf_wv)                 :: map_wv
    integer(kind=i_def), dimension(4)                      :: smap_wv_size
    integer(kind=i_def), parameter                         :: smap_wv_max = 2
    integer(kind=i_def), dimension(ndf_wv, smap_wv_max, 4) :: smap_wv
    real(kind=r_def),    dimension(undf_wv)                :: ls_wind
    real(kind=r_def),    dimension(undf_wv)                :: wind
    ! Multidata space
    integer(kind=i_def), parameter                         :: ndf_md  = 1_i_def
    integer(kind=i_def), parameter                         :: undf_md = 4_i_def*ndf_md*nlayers
    integer(kind=i_def), dimension(ndf_md)                 :: map_md
    integer(kind=i_def), dimension(4)                      :: smap_md_size
    integer(kind=i_def), parameter                         :: smap_md_max = 2
    integer(kind=i_def), dimension(ndf_md, smap_md_max, 4) :: smap_md
    real(kind=r_def),    dimension(undf_md)                :: wind_recon

    integer(kind=i_def) :: k, df

    map_ws = (/ 1 /)
    map_wv(1) = 1
    do df = 2,4
      map_wv(df) = map_wv(df-1) + nlayers
    end do
    map_md(1) = 1

    ! Set some values for the initial field
    do k = 0, nlayers - 1
      ls_wind(map_wv(1)+k) = 0.25_r_def + real(k,r_def)
      ls_wind(map_wv(3)+k) = 0.75_r_def + real(k,r_def)
      ls_wind(map_wv(2)+k) = -1.25_r_def - real(k,r_def)
      ls_wind(map_wv(4)+k) =  1.25_r_def + real(k,r_def)
    end do
    wind = -0.5_r_def*ls_wind

    do k = 0, nlayers-1
      wind_recon(map_md(1) + k + 0*nlayers) =-19.0_r_def - 3.52_r_def*real(k,r_def)
      wind_recon(map_md(1) + k + 1*nlayers) =-23.0_r_def + 1.46_r_def*real(k,r_def)
      wind_recon(map_md(1) + k + 2*nlayers) = 19.0_r_def + 3.52_r_def*real(k,r_def)
      wind_recon(map_md(1) + k + 3*nlayers) = 0.0_r_def
    end do

    ! Set up stencil maps
    smap_wv_size(:) = 2
    smap_wv = -1
    do k = 1,4
      smap_wv(:,1,k) = map_wv
      smap_wv(k,2,k) = map_wv(k)
    end do

    smap_md_size(:) = 2
    smap_md = map_md(1)

    m3_inv(:,:,:) = 0.1_r_def
    advective_update = 0.0_r_def

    call tl_w3h_advective_update_code(cell, nlayers,           &
                                      advective_update,        &
                                      wind_recon,              &
                                      smap_md_size,            &
                                      smap_md_max,             &
                                      smap_md,                 &
                                      ls_wind,                 &
                                      smap_wv_size,            &
                                      smap_wv_max,             &
                                      smap_wv,                 &
                                      wind,                    &
                                      ncell_3d, m3_inv,        &
                                      ndf_ws, undf_ws, map_ws, &
                                      ndf_md, undf_md, map_md, &
                                      ndf_wv, undf_wv, map_wv  &
                                     )

    select case(r_def)
    case(real64)
      tol = 1.0e-9_r_def
    case(real32)
      tol = 1.0e-6_r_def
    case default
      @assertFail("r_def precision not implemented")
    end select

    do k = 0,nlayers-1
      answer = -0.1_r_def*(0.5_r_def + real(k,r_def))*wind_recon(map_md(1)+k+2*nlayers)
      @assertEqual(answer, advective_update(map_ws(1)+k), tol)
    end do

  end subroutine test_all

end module tl_w3h_advective_update_kernel_mod_test
